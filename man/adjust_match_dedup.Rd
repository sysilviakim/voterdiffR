% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dedup_vrmatch.R
\name{adjust_match_dedup}
\alias{adjust_match_dedup}
\title{Dedupe Ties in vrmatch Output for All Snapshots}
\usage{
adjust_match_dedup(dedup_id = "lVoterUniqueID",
  dedup_prefix = "dedup_", dedup_suffix = "", date_df = NULL,
  start = "2018-04-26", end = "2021-01-01", path = "7z",
  pattern = "^(?=.*Cntywd_)(?!.*Hist)", file_type = ".txt",
  id = "\%m\%d\%y", rec = FALSE, per = 1, prefix = "Cntywd_",
  path_changes = "changes", path_reports = "reports",
  path_matches = "matches", vars_change = NULL,
  date_label = "date_label", nrow = "nrow")
}
\arguments{
\item{dedup_id}{The internal ID to correct for duplicates.
Default is "lVoterUniqueID".}

\item{dedup_prefix}{File prefix for saving deduped objects for all matches,
changes, and reports. Defaults to "dedup_". If set to empty string as well
as dedup_suffix, this will overwrite the existing pre-deduplication outputs,
and this must be done with caution.}

\item{dedup_suffix}{File suffix for saving deduped objects.}

\item{date_df}{List of snapshots. Defaults to NULL,
in which case the function will detect all snapshots available.}

\item{start}{The start date of the first snapshot.
Defaults to April 26, 2018.}

\item{end}{The end date of the last snapshot.
Defaults to Jan 1, 2021.}

\item{path}{Path where all snapshots are stored.
Defaults to subfolder 7z.}

\item{pattern}{Regular expression of the file pattern to find.
Defaults to a particular pattern of OCROV files.}

\item{file_type}{File type.
Defaults to .txt.}

\item{id}{How the snapshot files are formatted/labelled for their IDs.
Defaults to mdy.}

\item{rec}{Whether to find files recursively.
Defaults to FALSE.}

\item{per}{Period of each snapshot---whether daily, weekly, and so on.
Defaults to 1 (equivalent to "day"). Any valid input for base seq.Date
by argument is allowed.}

\item{prefix}{File name prefix.
Defaults to Cntywd_.}

\item{path_changes}{Path where the extracted changes are output to.
Defaults to "changes".}

\item{path_reports}{Path where the summarized changes are output to.
Defaults to "reports".}

\item{path_matches}{Path where the match outcomes are output to.
Defaults to "matches".}

\item{vars_change}{Variables to track changes of.
Defaults to NULL, which will then track all variables.}

\item{date_label}{Labels for dates (i.e., snapshot IDs), in `date_df`.
Defaults to "date_label".}

\item{nrow}{Name of list element which will contain the number of rows
of the input list dataframes.}
}
\value{
A named list of dataframes similar to vrmatch output but with
perfect duplicates by the matching variables cleaned.
}
\description{
This function takes the `vrmatch` output and deduplicates the probabilistic
record linkage output for all user-requested snapshots.
}
\details{
This happens because (1) the snapshot A was not deduplicated, but (2) when
snapshot B was. Hence, the old duplicates in A that are exact matches
with records in B (in terms of matching variables, not necessarily all)
force the remaining records in B to duplicated to be matched
to all the duplicates in A.

For instance, if you asked `dfA[c(1, 1, 2), ]` and `dfA[c(1, 2)]` to be
matched, it will give you three matched outcomes: `dfA[c(1, 1, 2), ]`,
even when `fastLink::dedupeMatches` has been called for.
It should be stressed that this is not a bug of fastLink, as it has
no means to distinguish these perfect ties.

In this function, we use the internal voter ID to correct for these
duplicates. Suppose that in snapshot A there are records with IDs a1 and a2
the same name, address, and date of birth, and in snapshot B, the duplicate
a2 has been deleted by the Registrar of Voters. Between two matches
(1) a1-a1 and (2) a2-a1, we drop (2), and classify a2 as "record only in A".

Note that this function is only relevant when using `vrmatch`
when the reference ID was not used to exclude exact matches. In addition,
after the deduplication, the EM object and et cetera from fastLink is
pre-deduplication, and hence cannot be used with the deduped `vrmatch`
object.
}
